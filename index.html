<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8">
    <title>Visualisation Audio Minimaliste</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        background: #222;
        color: white;
      }
      canvas {
        background: #333;
      }
    </style>
  </head>
  <body>
    <h1>Test Micro et Visualisation</h1>
    <canvas id="canvas" width="300" height="300"></canvas>
    <script>
      // Récupération du canvas et du contexte
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const centerX = width / 2;
      const centerY = height / 2;
      const radius = Math.min(width, height) * 0.3;

      // Variables pour le volume courant et l'état d'acquisition audio
      let currentVolume = 0;
      let audioAcquired = false;

      // Fonction de dessin du cercle en fonction de l'état et du volume
      const drawCircle = () => {
        ctx.clearRect(0, 0, width, height);

        if (!audioAcquired) {
          // Affiche un cercle rouge si le son n'est pas acquis
          ctx.fillStyle = "red";
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.closePath();
        } else {
          // Passe au vert sombre et s'illumine en fonction du volume
          // currentVolume est compris entre 0 et 255 ; on remappe la luminosité de 50% à 100%
          let lightness = Math.min(50 + (currentVolume / 255) * 50, 100);
          // Utilise HSL pour obtenir une teinte verte (120°)
          ctx.fillStyle = `hsl(120, 100%, ${lightness}%)`;
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.closePath();
        }
      };

      // Boucle d'animation
      const animate = () => {
        drawCircle();
        requestAnimationFrame(animate);
      };
      animate();

      // Tentative d'accès au microphone
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          audioAcquired = true;
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(stream);

          // Création d'un AnalyserNode pour traiter l'audio
          const analyser = audioContext.createAnalyser();
          analyser.fftSize = 2048;
          const bufferLength = analyser.fftSize;
          const dataArray = new Uint8Array(bufferLength);

          source.connect(analyser);

          // Fonction d'analyse du volume sonore
          const analyze = () => {
            analyser.getByteTimeDomainData(dataArray);
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
              // Le signal audio est centré sur 128, on calcule l'écart absolu
              let x = dataArray[i] - 128;
              sum += Math.abs(x);
            }
            let average = sum / bufferLength;
            // Remappe l'échelle du volume pour l'animation (0 à 255)
            currentVolume = Math.min(average * 3, 255);  // Facteur d'amplification ajustable
            requestAnimationFrame(analyze);
          };
          analyze();
        })
        .catch(err => {
          console.error("Erreur lors de l'accès au micro :", err);
        });
    </script>
  </body>
</html>
