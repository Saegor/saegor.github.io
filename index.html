<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8">
    <!-- Définition d'une Content Security Policy basique pour limiter les ressources autorisées -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'nonce-abc123'; style-src 'self' 'unsafe-inline'; connect-src 'self'">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisation Audio Minimaliste - Sécurisé</title>
    <style>
      /* Styles locaux pour limiter l'exposition à des ressources externes */
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        background: #222;
        color: white;
        font-family: sans-serif;
      }
      canvas {
        background: #333;
      }
      button {
        margin-top: 20px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <h1>Test Micro & Visualisation Sécurisé</h1>
    <canvas id="canvas" width="300" height="300"></canvas>
    <button id="startBtn">Démarrer l'acquisition audio</button>

    <!-- Utilisation d'un nonce (ici "abc123") pour autoriser le script en ligne -->
    <script nonce="abc123">
      'use strict';
      
      // Récupération sécurisée du canvas et du contexte
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const centerX = width / 2;
      const centerY = height / 2;
      const radius = Math.min(width, height) * 0.3;

      // Variables pour le volume courant et l'état d'acquisition audio
      let currentVolume = 0;
      let audioAcquired = false;
      let audioInitialized = false;

      // Fonction de dessin du cercle en fonction de l'état et du volume
      const drawCircle = () => {
        ctx.clearRect(0, 0, width, height);

        if (!audioAcquired) {
          // Affiche un cercle rouge si le son n'est pas acquis
          ctx.fillStyle = "red";
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.closePath();
        } else {
          // Passe au vert sombre et s'illumine en fonction du volume
          let lightness = Math.min(50 + (currentVolume / 255) * 50, 100);
          ctx.fillStyle = `hsl(120, 100%, ${lightness}%)`;
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.closePath();
        }
      };

      // Boucle d'animation utilisant requestAnimationFrame
      const animate = () => {
        drawCircle();
        requestAnimationFrame(animate);
      };
      animate();

      // Fonction d'initialisation audio
      const initAudio = () => {
        if (audioInitialized) return; // Évite plusieurs initialisations
        audioInitialized = true;

        // Demande d'accès au micro, qui doit être en HTTPS (ou localhost)
        navigator.mediaDevices.getUserMedia({ audio: true })
          .then(stream => {
            audioAcquired = true;
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);

            // Création d'un AnalyserNode pour analyser l'audio en temps réel
            const analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            const bufferLength = analyser.fftSize;
            const dataArray = new Uint8Array(bufferLength);

            source.connect(analyser);

            // Fonction d'analyse du volume sonore
            const analyze = () => {
              analyser.getByteTimeDomainData(dataArray);
              let sum = 0;
              for (let i = 0; i < bufferLength; i++) {
                let x = dataArray[i] - 128;
                sum += Math.abs(x);
              }
              let average = sum / bufferLength;
              currentVolume = Math.min(average * 3, 255); // Remappage dans [0, 255]
              requestAnimationFrame(analyze);
            };
            analyze();
          })
          .catch(err => {
            console.error("Erreur lors de l'accès au micro :", err);
          });
      };

      // Bouton pour lancer l'acquisition audio, déclenché par une action utilisateur
      const btn = document.getElementById('startBtn');
      btn.addEventListener('click', () => {
        initAudio();
        btn.disabled = true; // Désactivation du bouton après l'initialisation
        btn.innerText = "Audio en cours d'acquisition";
      });
    </script>
  </body>
</html>
